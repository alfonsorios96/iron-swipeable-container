<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="bower_components/polymer/polymer-element.html">
<link rel="import" href="bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<!--
`<iron-swipeable-container>` is a container that allows any of its nested
children (native or custom elements) to be swiped away. By default it supports
a curved or horizontal transition, but the transition duration and properties
can be customized.

Example:

    <iron-swipeable-container>
      <div>I can be swiped</div>
      <paper-card heading="Me too!"></paper-card>
    </iron-swipeable-container>

To disable swiping on individual children, you must give them the `.disable-swipe`
class. Alternatively, to disable swiping on the whole container, you can use its
`disable-swipe` attribute:

    <iron-swipeable-container>
      <div class="disable-swipe">I cannot be swiped be swiped</div>
      <paper-card heading="But I can!"></paper-card>
    </iron-swipeable-container>

    <iron-swipeable-container disable-swipe>
      <div>I cannot be swiped</div>
      <paper-card heading="Me neither :("></paper-card>
    </iron-swipeable-container>

It is a good idea to disable text selection on any of the children that you
want to be swiped:

    .swipe {
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: default;
    }

@group Iron Elements
@element iron-swipeable-container
@demo demo/index.html
-->

<dom-module id="iron-swipeable-container">
    <template>
        <content id="content">
            <slot></slot>
        </content>
    </template>
</dom-module>

<script>
    (function IronSwipeableContainer(customElements) {
        'use strict';

        const ZERO = 0;

        class IronSwipeableContainer extends Polymer.GestureEventListeners(Polymer.Element) {
            static get is() {
                return 'iron-swipeable-container';
            }

            /**
             * Fired when a child element is swiped away.
             *
             * @event iron-swipe
             */

            static get properties() {
                return {
                    /**
                     * The style in which to swipe the card. Currently supported
                     * options are `curve | horizontal`. If left unspecified, the default
                     * is assumed to be `horizontal`.
                     */
                    swipeStyle: {
                        type: String,
                        value: 'horizontal'
                    },

                    /**
                     * If true, then the container will not allow swiping.
                     */
                    disabled: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * The ratio of the width of the element that the translation animation
                     * should happen over. For example, if the `widthRatio` is 3, the
                     * animation will take place on a distance 3 times the width of the
                     * element being swiped.
                     */
                    widthRatio: {
                        type: Number,
                        value: 3
                    },

                    /**
                     * The ratio of the total animation distance after which the opacity
                     * transformation begins. For example, if the `widthRatio` is 1 and
                     * the `opacityRate` is 0.5, then the element needs to travel half its
                     * width before its opacity starts decreasing.
                     */
                    opacityRate: {
                        type: Number,
                        value: 0.2
                    },

                    /**
                     * The CSS transition applied while swiping.
                     */
                    transition: {
                        type: String,
                        value: '300ms cubic-bezier(0.4, 0.0, 1, 1)'
                    }
                };
            }

            ready() {
                super.ready();
                this._transitionProperty = 'opacity, transform';
                this._swipeComplete = false;
                this._direction = '';
            }

            connectedCallback() {
                super.connectedCallback();
                this._observer = new Polymer.FlattenedNodesObserver(this.$.content, (mutations) => {
                    for (let node of mutations.addedNodes) {
                        this._addListeners(node);
                    }

                    for (let node of mutations.removedNodes) {
                        this._removeListeners(node);
                    }
                });
            }

            disconnectedCallback() {
                super.disconnectedCallback();
                this._observer.disconnect();
            }

            _addListeners(node) {
                if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.COMMENT_NODE)
                    return;
                // Set up the animation.
                node.style.transitionProperty = this._transitionProperty;
                node.style.transition = this.transition;

                this._boundOnTrackListener = this._onTrack.bind(this);
                this._boundOnTransitionEndListener = this._onTransitionEnd.bind(this);
                Polymer.Gestures.addListener(node, 'track', (event => this._onTrack(event)));
            }

            _removeListeners(node) {
                if (node.nodeType === Node.TEXT_NODE)
                    return;
                Polymer.Gestures.removeListener(node, 'track', this._boundOnTrackListener);
            }

            _onTrack(event) {
                if (this.disabled)
                    return;

                const target = event.currentTarget;
                if (target.classList.contains('disable-swipe'))
                    return;

                let track = event.detail.state;
                event.stopPropagation();
                switch (track) {
                    case 'start':
                        this._trackStart(target);
                        break;
                    case 'track':
                        this._trackMove(event.detail.dx, target);
                        break;
                    case 'end':
                        this._trackEnd(event.detail.dx, target);
                        break;
                }
            }

            _trackStart(target) {
                // Save the width of the element, so that we don't trigger a style
                // recalc every time we need it.
                this._nodeWidth = target.offsetWidth;
                target.style.transition = 'none';
            }

            _trackMove(dx, target) {
                this._animate(dx, target);
            }

            _trackEnd(dx, target) {
                // The element is swiped away if it's moved halfway its total width.
                this._swipeComplete = Math.abs(dx) > this._nodeWidth / 2;
                this._direction = dx > 0;
                this._swipeEnd(target);
            }

            _animate(x, target) {
                let direction = x > 0 ? 1 : -1;

                // This is the total distance the animation will take place over.
                let totalDistance = this._nodeWidth * this.widthRatio;

                // Opacity distance overflow. `this._nodeWidth * this.opacityRate` is the
                // total distance the element needs to travel to become completely
                // transparent, and `x` is how much the element has already travelled.
                let opaqueDistance = Math.max(0, Math.abs(x) - this._nodeWidth * this.opacityRate);
                let opacity = Math.max(0, (totalDistance - opaqueDistance) / totalDistance);
                target.style.opacity = opacity;

                let translate, rotate;

                if (this.swipeStyle === 'horizontal') {
                    translate = `translate3d(${x}px,${ZERO}px,${ZERO})`;
                    rotate = '';
                } else {  // Default is assumed to be `curve`.
                    // Assume the element will be completely transparent at 90 degrees, so
                    // figure out the rotation and vertical displacement needed to
                    // achieve that.
                    let y = totalDistance - Math.sqrt(totalDistance * totalDistance - opaqueDistance * opaqueDistance);
                    let deg = (1 - opacity) * direction * 90;

                    translate = `translate3d(${x}px,${y}px,${ZERO})`;
                    rotate = ' rotate(' + deg + 'deg)';
                }
                this.__transform(translate + rotate, target);
            }

            _swipeEnd(target) {
                // Restore the original transition;
                target.style.transition = this.transition;

                if (this._swipeComplete) {
                    // If the element is ready to be swiped away, then translate it to the full
                    // transparency distance.
                    const totalDistance = this._nodeWidth * this.widthRatio;
                    this._animate(this._direction ? totalDistance : -totalDistance, target);
                } else {
                    this._animate(ZERO, target);
                }
            }

            _onTransitionEnd(event) {
                const target = event.currentTarget;

                if (this._swipeComplete && event.propertyName === 'opacity') {
                    this.removeChild(target);
                    this.dispatchEvent(new CustomEvent('iron-swipe', {
                        detail: {
                            direction: this._direction > 0 ? 'right' : 'left',
                            target: target
                        }
                    }));
                }
            }

            __transform(transformText, node) {
                node = /** @type {Element} */ (node || this);
                node.style.webkitTransform = transformText;
                node.style.transform = transformText;
            }
        }

        customElements.define(IronSwipeableContainer.is, IronSwipeableContainer);
    })(window.customElements);
</script>
